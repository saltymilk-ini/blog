<!DOCTYPE html><html><head><meta charset="utf-8"><title>My Personal Blog</title><link rel="stylesheet" href="./css/common.css"><link rel="stylesheet" href="./css/preview_area.css"></head><body><div class="page-title">欢迎来到我的个人博客</div><div class="page-subtitle">祝你今天过得开心!</div><div class="container"><main class="main-area"><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="./post_pages/2025-12/C++ 语言特性的变更可能让你的防御成为马奇诺防线.html">C++ 语言特性的变更可能让你的防御成为马奇诺防线</a></h2><p class="blog-preview-paragraph">本文通过对比历史上的马奇诺防线与代码中的防御机制，探讨了在C++编程中如何构建安全且易用的类接口。文章首先介绍了马奇诺防线的历史背景及其象征意义，随后引出在编写复杂功能模块时，开发者为了防止逻辑缺陷而采取的各种防御措施。接着，以一个具体的`MovieMode`类为例，展示了如何通过友元、私有构造函数和引用限定符等手段来增强代码的安全性，并讨论了这些措施在不同C++标准下的有效性。最后，文章总结了在语言特性变更时如何保持代码设计意图不变的经验教训。</p><div class="blog-preview-time-stamp">2025-12-12 17:05</div></div><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="./post_pages/2025-10/轻量级图片信息解析程序.html">轻量级图片信息解析程序</a></h2><p class="blog-preview-paragraph">本文介绍了作者为了解析图片文件基本信息（如宽度、高度、通道数和色深）而自行开发的一个C语言程序的过程。项目旨在仅解析文件头部信息而不读取像素数据，且不依赖第三方库。在开发过程中，作者遇到了二进制文件解析常见的问题，如大小端字节序转换与内存对齐，并分享了关于如何处理这些问题的经验。此外，文章还讨论了资料获取方式从传统搜索引擎向AI工具的转变及其带来的挑战。最后，作者提到了代码的一些遗留问题及后续改进措施。</p><div class="blog-preview-time-stamp">2025-10-23 19:09</div></div><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="./post_pages/2025-09/C++ 模板参数推导问题小记（模板类的模板构造函数）.html">C++ 模板参数推导问题小记（模板类的模板构造函数）</a></h2><p class="blog-preview-paragraph">本文探讨了在C++中实现一个模板类`point`时遇到的初始化问题，特别是如何正确限制数组长度和避免窄化转换。通过分析问题代码、理解C++的初始化机制（包括直接初始化与列表初始化），以及引入`std::enable_if`等技术手段来解决构造函数参数数量不匹配的问题，文章详细展示了如何改进模板构造函数以支持统一初始化语法，并确保接口易于正确使用且不易被误用。同时，文章还讨论了语义检查与代码优化之间的关系，强调了符合语言标准的重要性。</p><div class="blog-preview-time-stamp">2025-09-17 23:26</div></div><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="./post_pages/2025-08/C++ 使用分治减小模板递归深度.html">C++ 使用分治减小模板递归深度</a></h2><p class="blog-preview-paragraph">本文探讨了如何在C++中通过自定义模板和利用标准库来生成等差数列，首先介绍了使用递归方法实现的局限性——当序列长度较长时会导致模板递归深度超出编译器默认限制的问题。接着，文章提出了两种解决方案：一种是借鉴归并排序思想，采用分治策略降低递归深度；另一种则是基于C++17的新特性，结合`std::make_index_sequence`间接实现等差数列。最后，通过对比实验结果表明，在性能方面，基于标准库的方法显著优于自定义实现，并强调了在实际开发中优先选用经过优化的标准库的重要性。</p><div class="blog-preview-time-stamp">2025-08-24 17:36</div></div><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="./post_pages/2025-08/C++ 模板参数推导问题小记（非推导上下文）.html">C++ 模板参数推导问题小记（非推导上下文）</a></h2><p class="blog-preview-paragraph">本文探讨了C++模板参数推导中的非推导上下文问题，通过一个具体的代码示例展示了为何编译器无法从`std::enable_if`构造的别名模板中正确推导出类型，并详细分析了其原因及解决方案。文章还比较了几种AI编程助手对此问题的处理能力，强调了深入理解模板元编程规则的重要性以及在实际开发中谨慎使用AI建议的必要性。</p><div class="blog-preview-time-stamp">2025-08-04 18:33</div></div><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="./post_pages/2025-07/C++ 习惯RAII思想.html">C++ 习惯RAII思想</a></h2><p class="blog-preview-paragraph">本文介绍了RAII（资源获取即初始化）这一C++编程范式的核心思想及其重要作用，包括自动资源管理、异常安全、简化代码和提高可维护性。文章详细解释了RAII类的工作原理，通过构造函数、拷贝/移动函数以及析构函数来精确控制资源的生命周期，并提供了使用标准库RAII设施的具体示例，如容器类、文件流类、锁管理类和智能指针类。此外，还展示了如何创建自定义的RAII类，并讨论了在大型项目中应用RAII的重要性。</p><div class="blog-preview-time-stamp">2025-07-04 18:34</div></div><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="./post_pages/2025-05/C++ 智能指针的删除器.html">C++ 智能指针的删除器</a></h2><p class="blog-preview-paragraph">本文介绍了C++11引入的智能指针`shared_ptr`和`unique_ptr`中删除器的概念及其重要性，特别是在管理由C语言库创建、不能直接使用`delete`释放的资源时。文章展示了如何通过自定义删除器（如类、函数指针或lambda表达式）来正确释放这些资源，并解释了标准库提供的默认删除器如何简化对普通指针及数组形式指针的管理。此外，还探讨了不同编译器版本对`shared_ptr`支持数组形式特性的实现细节与差异。</p><div class="blog-preview-time-stamp">2025-05-19 18:33</div></div><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="./post_pages/2025-05/C++ 限制模板实参类型.html">C++ 限制模板实参类型</a></h2><p class="blog-preview-paragraph">本文介绍了如何在C++中通过概念（concept）和静态断言等技术手段，对模板实例化时的类型进行条件检查，以确保这些类型满足特定的要求。对于C++20及以上版本，使用`concept`能够简洁地定义类型约束并提供清晰的编译错误信息；而对于不支持C++20的环境，则展示了利用SFINAE（Substitution Failure Is Not An Error）机制结合宏定义实现类似功能的方法。此外，还讨论了将通用或扩展后的类型检查逻辑封装到基类中，以此提高代码复用性和维护性，并提到了这种做法不会增加额外的内存开销，因为编译器可以应用空基类优化策略。</p><div class="blog-preview-time-stamp">2025-05-06 15:42</div></div><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="./post_pages/2025-04/C++ ADL 与 模板.html">C++ ADL 与 模板</a></h2><p class="blog-preview-paragraph">本文介绍了ADL（Argument Dependent Lookup，参数依赖查找）的概念及其在C++中的应用。通过具体例子如`std::cout << "..."`解释了ADL如何扩展函数查找范围至参数所属的命名空间，并展示了ADL与模板结合时如何进一步扩大查找范围到模板实参的命名空间。此外，文章还探讨了利用ADL和模板实现基于不同模板实参自动选择调用相应函数的方法，从而支持编译期绑定和更灵活的代码组织方式。</p><div class="blog-preview-time-stamp">2025-04-29 16:10</div></div></main><sidebar class="side-bar"><div><h2 class="side-bar-title">Categories</h2><ul><li><a href="./categories/C.html">C(1)</a></li><li><a href="./categories/C++.html">C++(8)</a></li><li><a href="./categories/图像处理.html">图像处理(1)</a></li></ul></div><div><h2 class="side-bar-title">Archives</h2><ul><li><a href="./archives/2025-12.html">2025-12(1)</a></li><li><a href="./archives/2025-10.html">2025-10(1)</a></li><li><a href="./archives/2025-09.html">2025-09(1)</a></li><li><a href="./archives/2025-08.html">2025-08(2)</a></li><li><a href="./archives/2025-07.html">2025-07(1)</a></li><li><a href="./archives/2025-05.html">2025-05(2)</a></li><li><a href="./archives/2025-04.html">2025-04(1)</a></li></ul></div></sidebar></div></body></html>