<!DOCTYPE html><html><head><meta charset="utf-8"><title>C++ 使用分治减小模板递归深度</title><link rel="stylesheet" href="../../css/post_content.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"><link rel="stylesheet" href="../../css/common.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script></head><body><div class="page-title">C++ 使用分治减小模板递归深度</div><div class="container"><main class="main-area"><h1>起因</h1>
<p>C++14 引入 STL 的 make_index_sequence 可以生成一个类型为 std::size_t，0 到 N-1 的编译期序列，我们可以这样使用它：</p>
<details open>
<summary>代码</summary>
<pre><code>//利用函数参数推导提取序列
template&lt;std::size_t... Seq&gt;
void foo(std::index_sequence&lt;Seq...&gt;)
{
    //使用Seq
}<br>
//利用模板特化提取序列
template&lt;typename&gt;
struct extract_sequence;
template&lt;std::size_t... Seq&gt;
struct extract_sequence&lt;std::index_sequence&lt;Seq...&gt;&gt;
{
    //使用Seq
};<br>
foo(std::make_index_sequence&lt;5&gt;{});//foo内部得到 {0, 1, 2, 3, 4}
extract_sequence&lt;std::make_index_sequence&lt;3&gt;&gt;;//extract_sequence内部得到 {0, 1, 2}
</code></pre>
</details>
<p>可是在我的程序中，我想创建一个等差数列，std::make_index_sequence 无法直接拿来使用（其实可以间接使用，后文会提到）。于是我编写了一个自己的版本：</p>
<details open>
<summary>代码</summary>
<pre><code>//主模板，递归实例化
template&lt;std::size_t Base,std::size_t Step, std::size_t Count, std::size_t... Seq&gt;
struct make_arithmetic_progression : make_arithmetic_progression&lt;Base + Step, Step, Count-1, Seq..., Base&gt;
{<br>
};<br>
//递归终点特化版本
template&lt;std::size_t Base, std::size_t Step, std::size_t... Seq&gt;
struct make_arithmetic_progression&lt;Base, Step, 0, Seq...&gt;
{
    using type = std::index_sequence&lt;Seq...&gt;;
};<br>
template&lt;std::size_t Base, std::size_t Step, std::size_t Count&gt;
using arithmetic_progression = typename make_arithmetic_progression&lt;Base, Step, Count&gt;::type;<br>
foo(arithmetic_progression&lt;1, 2, 3&gt;{});//foo内部得到 {1, 3, 5}
extract_sequence&lt;arithmetic_progression&lt;3, 3, 3&gt;&gt;;//extract_sequence内部得到 {3, 6, 9}
</code></pre>
</details>
<h1>问题</h1>
<p>这个实现看起来没什么问题，可以正确地生成任意指定的等差数列。但是在一个偶然的情况下，我在创建一个很长的数列时，遇到以下错误：</p>
<div class="image">
<img src="../../images/19054914//3635299-20250823234645671-536386089.png" alt="recursive overflow">
</div>
<p>模板递归实例化深度超过限制了，查阅了一下资料，获知各家编译器都对这个深度有一个默认限制，GCC 和 clang 都是 1024，MSVC 是 499。</p>
<p>可以使用编译参数来指定这个限制：</p>
<details open>
<summary>代码</summary>
<pre><code>-ftemplate-depth=N //GCC 和 clang
/Zc:templateDepth=N //MSVC
</code></pre>
</details>
<p>但这显然是下策，每次编译这个模板都需要在编译时加上额外的指令，非常麻烦。</p>
<h1>解决</h1>
<h2>自定义方式</h2>
<p>我们知道有个排序算法叫归并排序，将长列表不断拆分成最小单元后合并。我们的这个数列实现也可以直接借鉴这个思路，拆分数组后合并：</p>
<details open>
<summary>代码</summary>
<pre><code>//list拼接类主模板
template&lt;typename, typename&gt;
struct index_list_concat;<br>
//list拼接类特化版本
template&lt;std::size_t... Seq1, std::size_t... Seq2&gt;
struct index_list_concat&lt;std::index_sequence&lt;Seq1...&gt;, std::index_sequence&lt;Seq2...&gt;&gt;
{
    using type = std::index_sequence&lt;Seq1..., Seq2...&gt;;
};<br>
//辅助分割主模板
template&lt;std::size_t Base, std::size_t Step, std::size_t Count&gt;
class make_arithmetic_progression
{
    static constexpr std::size_t HalfCount = Count / 2;
    static constexpr std::size_t HalfBase = Base + HalfCount * Step;<br>
public:
    using type = typename index_list_concat&lt;typename make_arithmetic_progression&lt;Base, Step, HalfCount&gt;::type,
                typename make_arithmetic_progression&lt;HalfBase, Step, Count - HalfCount&gt;::type&gt;::type;
};<br>
//拆分为1个元素特化版本
template&lt;std::size_t Base, std::size_t Step&gt;
class make_arithmetic_progression&lt;Base, Step, 1&gt;
{
public:
    using type = index_list&lt;Base&gt;;
};<br>
//拆分为2个元素特化版本
template&lt;std::size_t Base, std::size_t Step&gt;
class make_arithmetic_progression&lt;Base, Step, 2&gt;
{
public:
    using type = index_list&lt;Base, Base + Step&gt;;
};<br>
template&lt;std::size_t Base, std::size_t Step, std::size_t Count&gt;
using arithmetic_progression = typename make_arithmetic_progression&lt;Base, Step, Count&gt;::type;
</code></pre>
</details>
<p>这样对于长度为 Count 的序列，模板递归实例化的深度变为 $log_2Count$，按照 MSVC 的默认最大深度 499 来算，也能支持到 $2^{499}$ 长度的序列，这无论如何都够用了，更别说 GCC 和 clang 的 1024 了。</p>
<h2>借用标准库</h2>
<p>上文说到可以间接使用标准库来实现这个等差数列模板。在我们初中的时候就知道，可以用公差为 1 的等差数列生成任意的其他等差数列：</p>
$$
\begin{aligned}
a_n&=n (n=0,1,2,...)<br>\\\\
b_n&=a_n*d+k (n=0,1,2,...)//d为公差，k为首项
\end{aligned}
$$
结合 C++17 的折叠表达式，我们可以构建这样的模板：
<details open>
<summary>代码</summary>
<pre><code>//辅助推导函数
template&lt;std::size_t Base, std::size_t Step, std::size_t... Seq&gt;
std::index_sequence&lt;(Base + Step * Seq)...&gt; arithmetic_progression_helper(std::index_sequence&lt;Seq...&gt;);<br>
template&lt;std::size_t Base, std::size_t Step, std::size_t Count&gt;
using arithmetic_progression = decltype(arithmetic_progression_helper&lt;Base, Step&gt;(std::make_index_sequence&lt;Count&gt;{}));
</code></pre>
</details>
<p>这个模板只是在 STL 的 index_sequence 上做了一次包装，更加简洁。</p2>
<h1>优劣</h1>
<p>在我对上述两种实现进行测试时，发现在实例化超长的数列时，使用 STL 的版本无论在速度上还是内存消耗上都显著优于自定义版本。</p>
<p>比如在我的电脑上使用 clang 编译，实例化一个长度为 100000 的数列。STL 版本的实现编译耗时 1 秒左右，内存仅占用数十 MB；而自定义版本的编译却需要 10 秒左右，内存占用超过 1.2GB。</p>
<p>为什么相差如此悬殊？我于是很好奇 STL 是如何实现 make_index_sequence 的，找到源码后跟进去一瞧，它其实是 <code>__make_integer_seq&lt;std::size_t, N&gt;</code>。大家都知道，前导两个下划线的 STL 模板是内部实现版本，它们要么由编译器支持没有源码，要么有源码但不建议直接使用，这个 __make_integer_seq 属于前者。这些由编译器支持的模板大部分属于用户端不可能实现或者实现极为复杂，而在编译器端实现会相对简单并且高效的。</p>
<p>这提醒我们，对于标准库能够直接或间接支持的模块，应该优先选择使用标准库来实现，它们会帮我们最大化地利用资源。不过在学习过程中，编写自己的版本也是很有价值的，能够让我们深入细节，接触优秀的编码思想和优化策略。</p>
<h1>总结</h1>
<p>使用分治来降低模板递归实例化深度这一策略，是我以前从没考虑过的，虽然它在本次编码中被最终舍弃，但是日后说不定有用武之地。本篇学习记录梳理了我在逐步实现和改进等差数列模板的思路，总结如下：</p>
<p>1. 学习过程中不断造轮子加验证是获取和掌握知识的有效途径；</p>
<p>2. 在实际项目中，尽量使用经过大众检验的库有助于项目的稳定高效。</p>
<p>对于第二条，如果为了一个模块而引入一整个大型库的依赖，仍须仔细斟酌。这与本篇笔记的内容无关，但在实际工作中，如果每个人都为了实现一个简单模块而肆无忌惮的引入三方依赖，造成团队项目仓库中一大半是三方库内容的情况还是很让人不舒服的。</p></main></div><script>hljs.highlightAll();</script></body></html>