<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>C++ ADL 与 模板</title>
    <link rel="stylesheet" href="../../css/post_content.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs_2015.min.css">
    <link rel="stylesheet" href="../../css/common.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>

<body>
    <div class="page-title">C++ ADL 与 模板</div>
    <div class="container">
        <main class="main-area">
            <h1>什么是 ADL</h1>
            <p>ADL(Argument Dependent Lookup)，参数依赖查找，明确的意思是<b>依赖参数的函数查找</b>，即对于函数调用，不仅会依照常规的名称查找规则，还会在函数参数所在的命名空间内查找。
            </p>
            <p>我们常用的 <code>std::cout &lt;&lt; "..."</code> 其实就是一个 ADL 的例子，std::cout，查看一下 STL
                的代码，它是<code>std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;</code>，而这个类只定义了针对算术类型和指针类型的
                operator<< 并没有定义针对 const char * 的版本，使用编译器的跳转功能跳转到 << 的调用，其实是<br>
                    <code>template&lt;class _Traits&gt;<br>std::basic_ostream&lt;char, _Traits&gt; operator&lt;&lt;(std::basic_ostream&lt;char, _Traits&gt; &amp;, const char *)</code><br>
                    也就是说这个调用其实等价于 <code>operator&lt;&lt;(std::cout, "...")</code>，注意 operator<< 前并没有使用 std::
                        来指定查找位置，而这个对于 std::operator<< 的调用能顺利解析而不会触发 '没有与操作数匹配的操作符' 错误，正是由于 ADL 发挥了作用：第一个参数 std::cout
                        所在的命名空间 std 被加入到对 operator<< 的查找空间内，从而匹配到针对 const char * 的 operator<< 。</p>
                        <h1>ADL + 模板</h1>
                        <p>当函数参数是模板时，查找空间会扩展到参数模板所在的命名空间以及模板实参的命名空间：</p>
                        <details open>
                            <summary>代码</summary>
                            <pre><code>namespace space
{
struct A{};
template&lt;typename T&gt; struct TpA{};
template&lt;typename T, template&lt;typename&gt; class Tp&gt;
void foo(Tp&lt;T&gt; &){}
}
template&lt;typename T&gt; struct TpB{};
space::TpA&lt;int&gt; tai;
foo(tai);//通过TpA找到foo
TpB&lt;space::A&gt; tba;
foo(tba);//通过A找到foo
</code></pre>
                        </details>
                        <h1>根据模板实参自动选择调用函数</h1>
                        <p>ADL + 模板很容易就能实现根据模板实参调用不同函数的功能：</p>
                        <details open>
                            <summary>代码</summary>
                            <pre><code>namespace spaceA
{
struct A{};
void foo(A &){}
}
namespace spaceB
{
struct B{};
void foo(B &){}
}
...
template&lt;typename T&gt;
void dispatch(T &value)
{
  foo(value);
}
spaceA::A a;
dispatch(a);//绑定到spaceA::foo(spaceA::A &)
spaceB::B b;
dispatch(b);//绑定到spaceB::foo(spaceB::B &)
</code></pre>
                        </details>
                        <p>只要约定好接口，dispatch函数就能根据实例化类型来调用，可以实现松散的代码结构，并且函数的绑定在编译期进行。使用继承体系也能实现相同的需求，但是函数的调用是运行时解析。可以根据实际情况决定选用哪种方案。
                        </p>
        </main>
    </div>
    <script>hljs.highlightAll();</script>
</body>

</html>