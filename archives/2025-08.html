<!DOCTYPE html><html><head><meta charset="utf-8"><title>2025-08</title><link rel="stylesheet" href="../css/preview_area.css"><link rel="stylesheet" href="../css/common.css"></head><body><div class="page-title">2025-08</div><div class="container"><main class="main-area"><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="../post_pages/2025-08/C++ 使用分治减小模板递归深度.html">C++ 使用分治减小模板递归深度</a></h2><p class="blog-preview-paragraph">本文探讨了如何在C++中通过自定义模板和利用标准库来生成等差数列，首先介绍了使用递归方法实现的局限性——当序列长度较长时会导致模板递归深度超出编译器默认限制的问题。接着，文章提出了两种解决方案：一种是借鉴归并排序思想，采用分治策略降低递归深度；另一种则是基于C++17的新特性，结合`std::make_index_sequence`间接实现等差数列。最后，通过对比实验结果表明，在性能方面，基于标准库的方法显著优于自定义实现，并强调了在实际开发中优先选用经过优化的标准库的重要性。</p><div class="blog-preview-time-stamp">2025-08-24 17:36</div></div><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="../post_pages/2025-08/C++ 模板参数推导问题小记（非推导上下文）.html">C++ 模板参数推导问题小记（非推导上下文）</a></h2><p class="blog-preview-paragraph">本文探讨了C++模板参数推导中的非推导上下文问题，通过一个具体的代码示例展示了为何编译器无法从`std::enable_if`构造的别名模板中正确推导出类型，并详细分析了其原因及解决方案。文章还比较了几种AI编程助手对此问题的处理能力，强调了深入理解模板元编程规则的重要性以及在实际开发中谨慎使用AI建议的必要性。</p><div class="blog-preview-time-stamp">2025-08-04 18:33</div></div></div></body></html>