<!DOCTYPE html><html><head><meta charset="utf-8"><title>2025-05</title><link rel="stylesheet" href="../css/preview_area.css"><link rel="stylesheet" href="../css/common.css"></head><body><div class="page-title">2025-05</div><div class="container"><main class="main-area"><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="../post_pages/2025-05/C++ 智能指针的删除器.html">C++ 智能指针的删除器</a></h2><p class="blog-preview-paragraph">本文介绍了C++11引入的智能指针`shared_ptr`和`unique_ptr`中删除器的概念及其重要性，特别是在管理由C语言库创建、不能直接使用`delete`释放的资源时。文章展示了如何通过自定义删除器（如类、函数指针或lambda表达式）来正确释放这些资源，并解释了标准库提供的默认删除器如何简化对普通指针及数组形式指针的管理。此外，还探讨了不同编译器版本对`shared_ptr`支持数组形式特性的实现细节与差异。</p><div class="blog-preview-time-stamp">2025-05-19 18:33</div></div><div class="blog-preview-area"><h2 class="blog-preview-title"><a href="../post_pages/2025-05/C++ 限制模板实参类型.html">C++ 限制模板实参类型</a></h2><p class="blog-preview-paragraph">本文介绍了如何在C++中通过概念（concept）和静态断言等技术手段，对模板实例化时的类型进行条件检查，以确保这些类型满足特定的要求。对于C++20及以上版本，使用`concept`能够简洁地定义类型约束并提供清晰的编译错误信息；而对于不支持C++20的环境，则展示了利用SFINAE（Substitution Failure Is Not An Error）机制结合宏定义实现类似功能的方法。此外，还讨论了将通用或扩展后的类型检查逻辑封装到基类中，以此提高代码复用性和维护性，并提到了这种做法不会增加额外的内存开销，因为编译器可以应用空基类优化策略。</p><div class="blog-preview-time-stamp">2025-05-06 15:42</div></div></div></body></html>